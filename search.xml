<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RocketMQ实战(1)]]></title>
    <url>%2F2018%2F02%2F21%2FRocketMQ%E5%AE%9E%E6%88%98-1%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;RocketMQ是一款阿里自主开源的分布式消息中间件，其没有完全遵循JMS(JAVA Message Services)规范，并且和常用的ActiveMQ相比，具有很多优良的特性，并且在如今高负载，大流量的业务场景下完全可以胜任。 RocketMQ原生支持分布式，不用像ActiveMQ一样做额外的配置，单点式消息中间件 RocketMQ保证了消息的严格顺序，ActiveMQ可能会有消息错乱。 丰富的消息拉取模式。 亿级消息堆积能力 &nbsp;&nbsp;&nbsp;RocketMQ的发布订阅模式规定了其采用了Group机制实现消息的负载均衡。即根据Topic的消息数，均衡分布到每个Group相应的数据量，其中Group可以是一台机器或者一个进程。 RocketMQ的集群部署 多Master模式多个Master存在的模式，当一个Master宕机的时候，会由于其他的代替，缺点是宕机的Master上的消息无法再被订阅，除非复活。 多Master多Slave模式（同步双写）适用于并发量比较大的情况下，只有Master/Slave都成功才能成功，相比于异步辅助，提高了强一致性，但是减缓了读写速度 多Master单Slave模式（异步复制）Master/Slave有短暂的延迟，高可用模式，Master宕机的时候，Slavek可以读到消息，但是可能会有少量的信息丢失。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE中的默认VM-HotSpot]]></title>
    <url>%2F2018%2F02%2F03%2FJavaSE%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4VM-Hotspot%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”hot spot”故名思意,就是热点的意思，在JVM的执行引擎中，热点又通常指执行频率高的代码，而执行频率高的评判标准则是有很多种表现，如方法的执行次数，或者某条执行路径的次数。HotSpot内部的执行引擎采用混合执行模式，即包括解释器和自适应编译器（Adaptive-compile）. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虚拟机的默认配置下，初始化时所有的Java方法都由解释器执行，解释器记录着每个方法的执行次数和循环次数，并以这两个指标去判断一个方法的”热度”。等到一个方法足够”热”的时候，JVM就会启动该方法的编译，这种在所有执行过的代码里只寻找一部分编译的做法，叫自适应编译，为了实现动态编译，执行引擎需要多层，且一定有一层是进程初始阶段的编译，然后再让自适应编译处理其中的部分代码。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JIT编译（Just-in-time）即每当一部分代码要第一次准备执行时，将这部分代码编译。同时JIT编译和自适应编译都属于动态编译的范畴，其特点是在程序运行的时候进行编译，而不是在程序开始之前就进行编译，和静态编译相互区分。而在HotSpot中的VM是使用”JIT编译的（动态编译）”。其中的Client Compile(C1)和Sever Compile(C2)通常被称为”JIT编译器”。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作点滴0001]]></title>
    <url>%2F2017%2F08%2F16%2F%E5%B7%A5%E4%BD%9C%E7%82%B9%E6%BB%B40001%2F</url>
    <content type="text"><![CDATA[项目构建公司还在用svn,项目从里面checkout出来，然后ide导入本来是一件简单不过的事情，但是，但是，最后还是搞了一天。项目采用在IDE（eclipse）maven 导入的方式构建，经过漫长的jar包下载和配置文件Validation（后来才想起来该关掉这个……~.~），项目出现了3万+个errors,项目工程模块分的巨多，这也导致了问题排查的困难，一开始我也怀疑是maven配置文件的原因，最后真是，拿到了正确的配置文件，开心去替换了下，错误减少了点，而且剩下的大部分xxx cannot be resolved to a type这种错误，百度和google都试了一下，不得而解，最后试了某一个博客的方法，具体做法是： project-automatically 对勾给取消掉了，应该是防止自动构建用的选项， project-clean 项目clean 完毕,在progress视图里又看到了项目在自动构建（不解），可能会导致eclipse报错，栈溢出了（惊吓）。 项目右键，maven-update project,项目更新完毕，错误消失。 ###原因思考：网上的解释是eclipse和maven的clean并不同步（存疑解释）,另一种是因为某些特殊原因，eclipse没能自动编译(应该是maven生成的)源代码到build/classes（或其他classes目录），导致类型查找不到,(什么原因呢？) ###tips(项目执行这个命令会生成 mvn eclipse:eclipse 会自动生成相关的类文件，不需要在用maven 方式导入项目,以普通方式导入即可)。]]></content>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS[域名系统]基本解析]]></title>
    <url>%2F2017%2F06%2F27%2FDNS-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E6%9C%AC%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[DNS(Domain Name System)此协议根据域名解析到此域名对应的相应的ip地址，然后再来访问此IP地址对应得网站或者主机。首先，本机一定要知道DNS服务器的IP地址，否则上不了网，通过DNS服务器，才能知道某个域名的IP地址到底是什么,DNS服务器的IP地址，有可能是动态的，每次上网是由网关分配，这叫做DHCP机制，也有可能是事先固定的地址，一些公网的DNS服务器，也可以使用，其中最有名的就是Google的8.8.8.8和Level3 的4.2.2.2。 过程采用了分级查询–域名的层级结构如下：主机名（这是用户在自己的域里面为服务器分配的名称，用户可以任意分配）.次级域名.顶级域名.root(根域名，默认是省略的)。每一级都有自己的NS记录（NameServer）此记录指向该级域名的域名服务器，此服务器知道下一级域名的各种记录。 DNS服务器内置了根域名服务器的NS记录和IP地址（这些记录一般是不会变化的，）根域名服务器全世界只有13台，分别是从A.root-servers.net到M.root-servers.net。 然后DNS服务器向所有这些根域名服务器的IP地址发出”0查询0“请求，询问索要查询的域名（如：www.douyu.com）的顶级域名服务器com.的NS记录，最先回复的根域名服务器将被缓存，以后只向这台服务器发送请求. 接下来，DNS服务器向这些顶级域名服务器发出请求，询问次级域名douyu.com的NS记录，返回了此次级域名的四条NS记录和其对应的服务器名称和IP。 最后，DNS服务器向这些次级域名发送查询请求查询。主机层www对应的NS记录，返回相应的主机服务器和其对应的IP.此IP即是我们要的结果IP。]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
</search>
