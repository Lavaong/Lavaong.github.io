<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>l-tlon</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lavaong.github.io/"/>
  <updated>2018-02-21T14:07:11.548Z</updated>
  <id>https://lavaong.github.io/</id>
  
  <author>
    <name>Lavaong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RocketMQ实战(1)</title>
    <link href="https://lavaong.github.io/2018/02/21/RocketMQ%E5%AE%9E%E6%88%98-1/"/>
    <id>https://lavaong.github.io/2018/02/21/RocketMQ实战-1/</id>
    <published>2018-02-21T13:04:34.000Z</published>
    <updated>2018-02-21T14:07:11.548Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;RocketMQ是一款阿里自主开源的分布式消息中间件，其没有完全遵循JMS(JAVA Message Services)规范，并且和常用的ActiveMQ相比，具有很多优良的特性，并且在如今高负载，大流量的业务场景下完全可以胜任。</p>
<blockquote>
<ol>
<li>RocketMQ原生支持分布式，不用像ActiveMQ一样做额外的配置，<strong>单点式消息中间件</strong></li>
<li>RocketMQ保证了消息的严格顺序，ActiveMQ可能会有消息错乱。</li>
<li>丰富的消息拉取模式。</li>
<li>亿级消息堆积能力</li>
</ol>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;RocketMQ的发布订阅模式规定了其采用了Group机制实现消息的负载均衡。即根据Topic的消息数，均衡分布到每个Group相应的数据量，其中Group可以是一台机器或者一个进程。</p>
<h3 id="RocketMQ的集群部署"><a href="#RocketMQ的集群部署" class="headerlink" title="RocketMQ的集群部署"></a>RocketMQ的集群部署</h3><p><img src="C:/Users/Administrator/Desktop/blog-master/source/uploads/TB1lEPePXXXXXX8XXXXXXXXXXXX.png" alt="alt text"><br><img src="C:\Users\Administrator\Desktop\blog-master\source\uploads\TB1lEPePXXXXXX8XXXXXXXXXXXX.png" alt="alt text"></p>
<h4 id="多Master模式"><a href="#多Master模式" class="headerlink" title="多Master模式"></a>多Master模式</h4><p>多个Master存在的模式，当一个Master宕机的时候，会由于其他的代替，缺点是宕机的Master上的消息无法再被订阅，除非复活。</p>
<h4 id="多Master多Slave模式（同步双写）"><a href="#多Master多Slave模式（同步双写）" class="headerlink" title="多Master多Slave模式（同步双写）"></a>多Master多Slave模式（同步双写）</h4><p>适用于并发量比较大的情况下，只有Master/Slave都成功才能成功，相比于异步辅助，提高了强一致性，但是减缓了读写速度</p>
<h4 id="多Master单Slave模式（异步复制）"><a href="#多Master单Slave模式（异步复制）" class="headerlink" title="多Master单Slave模式（异步复制）"></a>多Master单Slave模式（异步复制）</h4><p>Master/Slave有短暂的延迟，高可用模式，Master宕机的时候，Slavek可以读到消息，但是可能会有少量的信息丢失。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;RocketMQ是一款阿里自主开源的分布式消息中间件，其没有完全遵循JMS(JAVA Message Services)规范，并且和常用的ActiveMQ相比，具有很多优良的特性，并且在如今高负载，大流量的业务场景下完全可以胜任。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://lavaong.github.io/categories/Java/"/>
    
    
      <category term="中间件" scheme="https://lavaong.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE中的默认VM-HotSpot</title>
    <link href="https://lavaong.github.io/2018/02/03/JavaSE%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4VM-Hotspot/"/>
    <id>https://lavaong.github.io/2018/02/03/JavaSE中的默认VM-Hotspot/</id>
    <published>2018-02-03T10:51:22.616Z</published>
    <updated>2018-02-21T12:18:21.172Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”hot spot”故名思意,就是热点的意思，在JVM的执行引擎中，热点又通常指执行频率高的代码，而执行频率高的评判标准则是有很多种表现，如<em>方法</em>的执行次数，或者<em>某条执行路径</em>的次数。HotSpot内部的执行引擎采用混合执行模式，即包括解释器和自适应编译器（Adaptive-compile）.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虚拟机的默认配置下，初始化时所有的Java方法都由解释器执行，解释器记录着每个方法的执行次数和循环次数，并以这两个指标去判断一个方法的”热度”。等到一个方法足够”热”的时候，JVM就会启动该方法的编译，这种在所有执行过的代码里只寻找一部分编译的做法，叫自适应编译，为了实现动态编译，执行引擎需要多层，且一定有一层是进程初始阶段的编译，然后再让自适应编译处理其中的部分代码。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JIT编译（Just-in-time）即每当一部分代码要第一次准备执行时，将这部分代码编译。同时JIT编译和自适应编译都属于动态编译的范畴，其特点是在程序运行的时候进行编译，而不是在程序开始之前就进行编译，和静态编译相互区分。而在HotSpot中的VM是使用”JIT编译的（<em>动态编译</em>）”。其中的Client Compile(C1)和Sever Compile(C2)通常被称为”JIT编译器”。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;”hot spot”故名思意,就是热点的意思，在JVM的执行引擎中，热点又通常指执行频率高的代码，而执行频率高的评判标准则是有很多种表现，如&lt;em&gt;方法&lt;/em&gt;的执行次数，或者&lt;em&gt;某条执行路径&lt;/
    
    </summary>
    
      <category term="Java" scheme="https://lavaong.github.io/categories/Java/"/>
    
    
      <category term="虚拟机" scheme="https://lavaong.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>工作点滴0001</title>
    <link href="https://lavaong.github.io/2017/08/16/%E5%B7%A5%E4%BD%9C%E7%82%B9%E6%BB%B40001/"/>
    <id>https://lavaong.github.io/2017/08/16/工作点滴0001/</id>
    <published>2017-08-16T09:05:38.000Z</published>
    <updated>2017-08-16T10:11:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h1><h3 id="公司还在用svn-项目从里面checkout出来，然后ide导入本来是一件简单不过的事情，但是，但是，最后还是搞了一天。"><a href="#公司还在用svn-项目从里面checkout出来，然后ide导入本来是一件简单不过的事情，但是，但是，最后还是搞了一天。" class="headerlink" title="公司还在用svn,项目从里面checkout出来，然后ide导入本来是一件简单不过的事情，但是，但是，最后还是搞了一天。"></a>公司还在用svn,项目从里面checkout出来，然后ide导入本来是一件简单不过的事情，但是，但是，最后还是搞了一天。</h3><p>项目采用在IDE（eclipse）maven 导入的方式构建，经过漫长的jar包下载和配置文件Validation（后来才想起来该关掉这个……~.~），项目出现了3万+个errors,项目工程模块分的巨多，这也导致了问题排查的困难，一开始我也怀疑是maven配置文件的原因，最后真是，拿到了正确的配置文件，开心去替换了下，错误减少了点，而且剩下的大部分xxx cannot be resolved to a type这种错误，百度和google都试了一下，不得而解，最后试了某一个博客的方法，具体做法是：</p>
<ol>
<li>project-automatically 对勾给取消掉了，应该是防止自动构建用的选项，</li>
<li>project-clean</li>
<li>项目clean 完毕,在progress视图里又看到了项目在自动构建（不解），可能会导致eclipse报错，栈溢出了（惊吓）。</li>
<li>项目右键，maven-update project,项目更新完毕，错误消失。</li>
</ol>
<p>###原因思考：<br>网上的解释是eclipse和maven的clean并不同步（存疑解释）,另一种是因为某些特殊原因，eclipse没能自动编译(应该是maven生成的)源代码到build/classes（或其他classes目录），导致类型查找不到,(什么原因呢？)</p>
<p>###tips(项目执行这个命令会生成 mvn eclipse:eclipse 会自动生成相关的类文件，不需要在用maven 方式导入项目,以普通方式导入即可)。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;项目构建&quot;&gt;&lt;a href=&quot;#项目构建&quot; class=&quot;headerlink&quot; title=&quot;项目构建&quot;&gt;&lt;/a&gt;项目构建&lt;/h1&gt;&lt;h3 id=&quot;公司还在用svn-项目从里面checkout出来，然后ide导入本来是一件简单不过的事情，但是，但是，最后还是搞了
    
    </summary>
    
    
      <category term="学习" scheme="https://lavaong.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>DNS[域名系统]基本解析</title>
    <link href="https://lavaong.github.io/2017/06/27/DNS-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E6%9C%AC%E8%A7%A3%E6%9E%90/"/>
    <id>https://lavaong.github.io/2017/06/27/DNS-域名系统-基本解析/</id>
    <published>2017-06-27T02:47:03.000Z</published>
    <updated>2018-02-21T13:20:20.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS-Domain-Name-System"><a href="#DNS-Domain-Name-System" class="headerlink" title="DNS(Domain Name System)"></a>DNS(Domain Name System)</h1><p>此协议根据域名解析到此域名对应的相应的ip地址，然后再来访问此IP地址对应得网站或者主机。首先，本机一定要知道DNS服务器的IP地址，否则上不了网，通过DNS服务器，才能知道某个域名的IP地址到底是什么,DNS服务器的IP地址，有可能是动态的，每次上网是由网关分配，这叫做DHCP机制，也有可能是事先固定的地址，一些公网的DNS服务器，也可以使用，其中最有名的就是Google的8.8.8.8和Level3 的4.2.2.2。</p>
<h3 id="过程采用了分级查询–域名的层级结构如下："><a href="#过程采用了分级查询–域名的层级结构如下：" class="headerlink" title="过程采用了分级查询–域名的层级结构如下："></a>过程采用了分级查询–域名的层级结构如下：</h3><p>主机名（这是用户在自己的域里面为服务器分配的名称，用户可以任意分配）.次级域名.顶级域名.root(根域名，默认是省略的)。每一级都有自己的NS记录（NameServer）此记录指向该级域名的域名服务器，此服务器知道下一级域名的各种记录。</p>
<ol>
<li>DNS服务器内置了根域名服务器的NS记录和IP地址（这些记录一般是不会变化的，）根域名服务器全世界只有13台，分别是从A.root-ser<br>vers.net到M.root-servers.net。</li>
<li>然后DNS服务器向所有这些根域名服务器的IP地址发出”0查询0“请求，询问索要查询的域名（如：www.douyu.com）的顶级域名服务器<br>com.的NS记录，最先回复的根域名服务器将被缓存，以后只向这台服务器发送请求.     </li>
<li>接下来，DNS服务器向这些顶级域名服务器发出请求，询问次级域名douyu.com的NS记录，返回了此次级域名的四条NS记录和其对应的服务<br>器名称和IP。</li>
<li>最后，DNS服务器向这些次级域名发送查询请求查询。主机层www对应的NS记录，返回相应的主机服务器和其对应的IP.此IP即是我们要的结<br>果IP。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;DNS-Domain-Name-System&quot;&gt;&lt;a href=&quot;#DNS-Domain-Name-System&quot; class=&quot;headerlink&quot; title=&quot;DNS(Domain Name System)&quot;&gt;&lt;/a&gt;DNS(Domain Name Sys
    
    </summary>
    
      <category term="Other" scheme="https://lavaong.github.io/categories/Other/"/>
    
    
      <category term="学习" scheme="https://lavaong.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
